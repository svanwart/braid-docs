<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Layered SNN Visualization</title>
    <style>
      body {
        margin: 0;
        background: #f9fafb;
        font-family: sans-serif;
        text-align: center;
      }
      canvas {
        display: block;
        margin: auto;
      }
      h1 {
        margin-top: 1rem;
        font-size: 1.5rem;
      }
    </style>
  </head>
  <body>
    <h1>Spiking Neural Network - Layered Visualization</h1>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script>
      const layers = {
        input: [],
        excitatory: [],
        inhibitory: [],
        output: [],
      }

      const spikeTrains = [
        [10, 12, 1],
        [11, 13, 5],
        [9, 11, 13],
        [10, 12, 13],
        [5, 10, 27], // anomalous input
      ]

      let currentExample = 0
      let spikes = spikeTrains[currentExample]
      let timer = 0
      let firingThreshold = 2
      let pauseFrames = 60
      let pauseCounter = 0

      function setup() {
        createCanvas(800, 400)
        frameRate(30)
        initNetwork()
      }

      function initNetwork() {
        const layerSpacing = width / 5
        const nodeSpacing = 80

        for (let i = 0; i < 3; i++) {
          layers.input.push({
            x: layerSpacing * 1,
            y: 100 + i * nodeSpacing,
            spiked: false,
          })
          layers.excitatory.push({
            x: layerSpacing * 2,
            y: 100 + i * nodeSpacing,
            active: false,
            weight: 1,
          })
          layers.inhibitory.push({
            x: layerSpacing * 3,
            y: 100 + i * nodeSpacing,
            active: false,
          })
        }

        layers.output.push({
          x: layerSpacing * 4,
          y: height / 2,
          active: false,
        })
      }

      function resetActivity() {
        for (let i = 0; i < 3; i++) {
          layers.input[i].spiked = false
          layers.excitatory[i].active = false
          layers.inhibitory[i].active = false
        }
        layers.output[0].active = false
      }

      function draw() {
        background(255)
        drawConnections()
        drawNetwork()
        simulateSpikes()
      }

      function simulateSpikes() {
        if (pauseCounter > 0) {
          pauseCounter--
          return
        }

        // Reset excitatory activity at the start of each frame
        for (let i = 0; i < layers.excitatory.length; i++) {
          layers.excitatory[i].active = false
        }

        // Reset inhibitory activity at the start of each frame
        for (let i = 0; i < layers.inhibitory.length; i++) {
          layers.inhibitory[i].active = false
        }

        // Activate neurons based on spike timing
        for (let i = 0; i < layers.input.length; i++) {
          if (timer === spikes[i]) {
            layers.input[i].spiked = true
            layers.excitatory[i].active = true
          }
        }

        // Find the first active excitatory neuron (winner-takes-all)
        let firstActiveIndex = -1
        for (let i = 0; i < layers.excitatory.length; i++) {
          if (layers.excitatory[i].active) {
            firstActiveIndex = i
            break
          }
        }

        // Only the first active excitatory neuron activates its inhibitory neuron
        if (firstActiveIndex !== -1) {
          layers.inhibitory[firstActiveIndex].active = true

          // This inhibitory neuron suppresses all other excitatory neurons
          for (let j = 0; j < layers.excitatory.length; j++) {
            if (j !== firstActiveIndex) {
              layers.excitatory[j].active = false
            }
          }
        }

        const spikeTimes = layers.input.map((n, i) =>
          n.spiked ? spikes[i] : null,
        )
        if (spikeTimes.every((t) => t !== null)) {
          const diffs = Math.max(...spikeTimes) - Math.min(...spikeTimes)
          if (diffs <= firingThreshold * 5) {
            layers.output[0].active = true
          }
          pauseCounter = pauseFrames
          timer = 0
          currentExample = (currentExample + 1) % spikeTrains.length
          spikes = spikeTrains[currentExample]
          resetActivity()
        } else {
          timer++
        }
      }

      function drawConnections() {
        strokeWeight(1)
        for (let i = 0; i < 3; i++) {
          // Input to excitatory connections
          stroke(0, 0, 255, 100)
          line(
            layers.input[i].x,
            layers.input[i].y,
            layers.excitatory[i].x,
            layers.excitatory[i].y,
          )

          // Excitatory to inhibitory connections (matching pairs)
          stroke(0, 150, 255, 120)
          line(
            layers.excitatory[i].x,
            layers.excitatory[i].y,
            layers.inhibitory[i].x,
            layers.inhibitory[i].y,
          )

          // Inhibitory to excitatory connections (cross-inhibition)
          stroke(255, 0, 0, 80)
          for (let j = 0; j < 3; j++) {
            if (i !== j) {
              line(
                layers.inhibitory[i].x,
                layers.inhibitory[i].y,
                layers.excitatory[j].x,
                layers.excitatory[j].y,
              )
            }
          }

          // Excitatory to output connections
          stroke(0, 200, 0, 100)
          line(
            layers.excitatory[i].x,
            layers.excitatory[i].y,
            layers.output[0].x,
            layers.output[0].y,
          )
        }
      }

      function drawNetwork() {
        drawLayer(layers.input, 'gray', 'Input')
        drawLayer(layers.excitatory, 'blue', 'Excitatory')
        drawLayer(layers.inhibitory, 'red', 'Inhibitory')
        drawLayer(
          layers.output,
          layers.output[0].active ? 'gold' : 'green',
          'Output',
        )
      }

      function drawLayer(nodes, color, label) {
        textAlign(CENTER)
        textSize(12)
        noStroke()
        fill(0)
        if (nodes.length > 0) text(label, nodes[0].x, 30)

        for (let node of nodes) {
          stroke(0)
          fill(node.active || node.spiked ? color : 'white')
          ellipse(node.x, node.y, 30)
        }
      }
    </script>
  </body>
</html>
