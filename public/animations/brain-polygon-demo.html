<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Brain Polygon Calculator Demo</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background-color: #f5f5f5;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      h1 {
        color: #333;
        text-align: center;
      }
      .controls {
        text-align: center;
        margin: 20px 0;
      }
      button {
        background: #007bff;
        color: white;
        border: none;
        padding: 10px 20px;
        margin: 0 5px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
      }
      button:hover {
        background: #0056b3;
      }
      button.active {
        background: #28a745;
      }
      .tile-controls {
        text-align: center;
        margin: 10px 0;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 5px;
      }
      .tile-controls label {
        margin: 0 10px;
        font-size: 14px;
      }
      .tile-controls input[type='range'] {
        width: 100px;
        margin: 0 5px;
      }
      canvas {
        border: 1px solid #ddd;
        display: block;
        margin: 20px auto;
        background: white;
        cursor: crosshair;
      }
      .info {
        text-align: center;
        color: #666;
        margin: 10px 0;
      }
      .coordinates {
        background: #f8f9fa;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        max-height: 200px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 12px;
      }
      .stats {
        display: flex;
        justify-content: space-around;
        margin: 10px 0;
        padding: 10px;
        background: #e9ecef;
        border-radius: 5px;
      }
      .stat {
        text-align: center;
      }
      .stat-value {
        font-size: 18px;
        font-weight: bold;
        color: #007bff;
      }
      .stat-label {
        font-size: 12px;
        color: #666;
      }
      .interaction-controls {
        text-align: center;
        margin: 10px 0;
        padding: 10px;
        background: #fff3cd;
        border-radius: 5px;
        border: 1px solid #ffeaa7;
      }
      .interaction-controls button {
        background: #ff6b6b;
        margin: 0 5px;
      }
      .interaction-controls button:hover {
        background: #ee5a52;
      }
      .interaction-controls button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Brain Polygon Calculator Demo</h1>

      <div class="controls">
        <button onclick="showPolygon('convex')" id="btn-convex">
          Convex Hull
        </button>
        <button onclick="showPolygon('bounding')" id="btn-bounding">
          Bounding Box
        </button>
        <button onclick="showPolygon('alpha')" id="btn-alpha">
          Alpha Shape
        </button>
        <button onclick="showBrainOnly()" id="btn-brain">Brain Only</button>
      </div>

      <div class="tile-controls">
        <label>
          <input type="checkbox" id="showTiles" onchange="toggleTiles()" /> Show
          Tiles
        </label>
        <label>
          Tile Size:
          <input
            type="range"
            id="tileSize"
            min="10"
            max="50"
            value="20"
            onchange="updateTiles()"
          />
          <span id="tileSizeValue">20px</span>
        </label>
        <label>
          Tile Opacity:
          <input
            type="range"
            id="tileOpacity"
            min="0.1"
            max="1"
            step="0.1"
            value="0.3"
            onchange="updateTiles()"
          />
          <span id="tileOpacityValue">0.3</span>
        </label>
        <label>
          <input
            type="checkbox"
            id="showTileBorders"
            onchange="updateTiles()"
          />
          Show Tile Borders
        </label>
      </div>

      <div class="interaction-controls">
        <label>
          <input
            type="checkbox"
            id="enableInteraction"
            onchange="toggleInteraction()"
          />
          Enable Chain Reaction
        </label>
        <button onclick="clearChainReaction()" id="clearBtn" disabled>
          Clear Reaction
        </button>
        <button onclick="resetTiles()" id="resetBtn" disabled>Reset All</button>
        <span id="chainInfo">Click tiles to start chain reaction!</span>
      </div>

      <div class="tile-controls">
        <label>
          <input
            type="checkbox"
            id="autoTurnOff"
            checked
            onchange="updateAutoTurnOff()"
          />
          Auto Turn-Off
        </label>
        <label>
          Turn-Off Delay:
          <input
            type="range"
            id="turnOffDelay"
            min="10"
            max="200"
            value="50"
            onchange="updateAutoTurnOff()"
          />
          <span id="turnOffDelayValue">50ms</span>
        </label>
        <label>
          Hold Time:
          <input
            type="range"
            id="holdTime"
            min="500"
            max="3000"
            step="100"
            value="1000"
            onchange="updateAutoTurnOff()"
          />
          <span id="holdTimeValue">1000ms</span>
        </label>
      </div>

      <div class="stats">
        <div class="stat">
          <div class="stat-value" id="totalTiles">0</div>
          <div class="stat-label">Total Tiles</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="coveredArea">0%</div>
          <div class="stat-label">Coverage</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="polygonVertices">0</div>
          <div class="stat-label">Polygon Vertices</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="litTiles">0</div>
          <div class="stat-label">Lit Tiles</div>
        </div>
      </div>

      <div class="info">
        <span id="polygon-info"
          >Click a button to see different polygon types</span
        >
      </div>

      <canvas id="brainCanvas" width="800" height="600"></canvas>

      <div class="coordinates">
        <strong>Polygon Coordinates:</strong>
        <div id="coordinates-display">No polygon selected</div>
      </div>
    </div>

    <!-- Load the brain coordinates first -->
    <script src="brain-coords.js"></script>

    <!-- Load the polygon calculator -->
    <script src="brain-polygon-calculator.js"></script>

    <script>
      const canvas = document.getElementById('brainCanvas')
      const ctx = canvas.getContext('2d')
      let currentPolygon = null
      let polygonType = null
      let tiles = []
      let showTiles = false
      let enableInteraction = false
      let litTiles = new Set()
      let chainReactionActive = false
      let animationFrame = null

      // Scale and offset for better visualization
      const scale = 0.8
      const offsetX = 100
      const offsetY = 50

      function transformPoint(point) {
        return [point[0] * scale + offsetX, point[1] * scale + offsetY]
      }

      function untransformPoint(point) {
        return [(point[0] - offsetX) / scale, (point[1] - offsetY) / scale]
      }

      // Point-in-polygon test using ray casting algorithm
      function pointInPolygon(point, polygon) {
        let inside = false
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          if (
            polygon[i][1] > point[1] !== polygon[j][1] > point[1] &&
            point[0] <
              ((polygon[j][0] - polygon[i][0]) * (point[1] - polygon[i][1])) /
                (polygon[j][1] - polygon[i][1]) +
                polygon[i][0]
          ) {
            inside = !inside
          }
        }
        return inside
      }

      // Generate tiles that cover the polygon
      function generateTiles(polygon, tileSize = 20) {
        if (!polygon || polygon.length < 3) return []

        // Find bounding box of the polygon
        let minX = polygon[0][0],
          maxX = polygon[0][0]
        let minY = polygon[0][1],
          maxY = polygon[0][1]

        for (const [x, y] of polygon) {
          minX = Math.min(minX, x)
          maxX = Math.max(maxX, x)
          minY = Math.min(minY, y)
          maxY = Math.max(maxY, y)
        }

        // Generate tiles
        const tiles = []
        for (let x = minX; x <= maxX; x += tileSize) {
          for (let y = minY; y <= maxY; y += tileSize) {
            // Check if tile center is inside polygon
            const centerX = x + tileSize / 2
            const centerY = y + tileSize / 2

            if (pointInPolygon([centerX, centerY], polygon)) {
              tiles.push({
                x: x,
                y: y,
                size: tileSize,
                centerX: centerX,
                centerY: centerY,
                id: `${Math.floor(x / tileSize)}_${Math.floor(y / tileSize)}`,
                lit: false,
                brightness: 0,
                animationStart: 0,
              })
            }
          }
        }

        return tiles
      }

      // Find adjacent tiles
      function findAdjacentTiles(tile, allTiles) {
        const tileSize = tile.size
        const adjacent = []

        // Check all 8 directions
        const directions = [
          [-tileSize, 0], // left
          [tileSize, 0], // right
          [0, -tileSize], // up
          [0, tileSize], // down
          [-tileSize, -tileSize], // top-left
          [tileSize, -tileSize], // top-right
          [-tileSize, tileSize], // bottom-left
          [tileSize, tileSize], // bottom-right
        ]

        for (const [dx, dy] of directions) {
          const adjacentTile = allTiles.find(
            (t) => t.x === tile.x + dx && t.y === tile.y + dy,
          )
          if (adjacentTile && !adjacentTile.lit) {
            adjacent.push(adjacentTile)
          }
        }

        return adjacent
      }

      // Chain reaction function
      async function chainReaction(startTile) {
        if (chainReactionActive) return
        chainReactionActive = true

        console.log('Starting chain reaction with tile:', startTile.id)

        const queue = [startTile]
        const delay = 100 // milliseconds between each wave

        while (queue.length > 0) {
          const currentTile = queue.shift()

          if (!currentTile.lit) {
            // Light up current tile
            currentTile.lit = true
            currentTile.animationStart = Date.now()
            litTiles.add(currentTile.id)

            console.log(
              `Lit tile ${currentTile.id} at ${currentTile.animationStart}`,
            )

            // Find adjacent unlit tiles (only unlit tiles)
            const adjacent = findAdjacentTiles(currentTile, tiles)

            // Randomly select 2 adjacent tiles (or all if less than 2)
            const selectedAdjacent = []
            if (adjacent.length <= 2) {
              selectedAdjacent.push(...adjacent)
            } else {
              // Shuffle and take first 2
              const shuffled = [...adjacent].sort(() => Math.random() - 0.5)
              selectedAdjacent.push(shuffled[0], shuffled[1])
            }

            // Add selected adjacent tiles to queue (only if they're not already lit)
            for (const adjacentTile of selectedAdjacent) {
              if (!adjacentTile.lit && !queue.includes(adjacentTile)) {
                queue.push(adjacentTile)
              }
            }

            // Update stats
            updateChainStats()

            // Force a redraw to see the changes immediately
            redraw()

            // Wait before next wave
            if (queue.length > 0) {
              await new Promise((resolve) => setTimeout(resolve, delay))
            }
          }
        }

        chainReactionActive = false
        updateChainInfo()
        console.log('Chain reaction complete. Total lit tiles:', litTiles.size)

        // Start the auto-turn-off process after the hold time
        const holdTime = parseInt(document.getElementById('holdTime').value)
        setTimeout(() => {
          if (document.getElementById('autoTurnOff').checked) {
            startAutoTurnOff()
          }
        }, holdTime)
      }

      // Auto turn-off function
      function startAutoTurnOff() {
        console.log('Starting auto turn-off process')

        const turnOffDelay = parseInt(
          document.getElementById('turnOffDelay').value,
        )
        const litTilesArray = Array.from(litTiles)

        let index = 0

        function turnOffNextTile() {
          if (index >= litTilesArray.length) {
            console.log('Auto turn-off complete')
            return
          }

          const tileId = litTilesArray[index]
          const tile = tiles.find((t) => t.id === tileId)

          if (tile) {
            tile.lit = false
            tile.animationStart = 0
            litTiles.delete(tileId)

            console.log(`Turned off tile ${tileId}`)
            updateChainStats()
            redraw()
          }

          index++

          // Continue with next tile
          setTimeout(turnOffNextTile, turnOffDelay)
        }

        turnOffNextTile()
      }

      function updateChainStats() {
        document.getElementById('litTiles').textContent = litTiles.size
        document.getElementById('clearBtn').disabled = litTiles.size === 0
        document.getElementById('resetBtn').disabled = litTiles.size === 0
      }

      function updateChainInfo() {
        const info = document.getElementById('chainInfo')
        if (chainReactionActive) {
          info.textContent = 'Chain reaction in progress...'
        } else if (litTiles.size > 0) {
          info.textContent = `Chain reaction complete! ${litTiles.size} tiles lit.`
        } else {
          info.textContent = 'Click tiles to start chain reaction!'
        }
      }

      function clearChainReaction() {
        litTiles.clear()
        for (const tile of tiles) {
          tile.lit = false
          tile.brightness = 0
          tile.animationStart = 0
        }
        updateChainStats()
        updateChainInfo()
        redraw()
      }

      function resetTiles() {
        clearChainReaction()
      }

      function toggleInteraction() {
        enableInteraction = document.getElementById('enableInteraction').checked
        if (!enableInteraction) {
          clearChainReaction()
        }
        updateChainInfo()
      }

      function updateAutoTurnOff() {
        const turnOffDelay = parseInt(
          document.getElementById('turnOffDelay').value,
        )
        const holdTime = parseInt(document.getElementById('holdTime').value)

        document.getElementById('turnOffDelayValue').textContent =
          turnOffDelay + 'ms'
        document.getElementById('holdTimeValue').textContent = holdTime + 'ms'
      }

      function drawTiles() {
        if (!showTiles || !tiles.length) return

        const opacity = parseFloat(document.getElementById('tileOpacity').value)
        const showBorders = document.getElementById('showTileBorders').checked

        ctx.save()

        for (const tile of tiles) {
          const transformedTile = {
            x: tile.x * scale + offsetX,
            y: tile.y * scale + offsetY,
            size: tile.size * scale,
          }

          // Calculate brightness for lit tiles
          let brightness = 0
          if (tile.lit) {
            const elapsed = Date.now() - tile.animationStart
            const duration = 2000 // 2 second animation for more visible effect
            brightness = Math.min(1, elapsed / duration)

            // Add pulsing effect
            const pulse = Math.sin(elapsed * 0.01) * 0.2 + 0.8 // Pulsing between 0.6 and 1.0
            brightness *= pulse

            // Debug: log the first few lit tiles
            if (litTiles.size <= 5) {
              console.log(
                `Tile ${tile.id}: lit=${tile.lit}, brightness=${brightness.toFixed(2)}, elapsed=${elapsed}ms`,
              )
            }
          }

          // Set fill color based on lit state with MUCH more dramatic changes
          if (tile.lit) {
            // Very dramatic color transition: green -> bright red
            const hue = 120 - brightness * 120 // 120 (green) to 0 (red)
            const saturation = 100 // Always 100% saturation
            const lightness = 50 + brightness * 30 // 50% to 80%

            ctx.globalAlpha = 1.0 // Full opacity for lit tiles
            ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`
          } else {
            ctx.globalAlpha = opacity
            ctx.fillStyle = '#4CAF50'
          }

          // Fill tile
          ctx.fillRect(
            transformedTile.x,
            transformedTile.y,
            transformedTile.size,
            transformedTile.size,
          )

          // Draw border if enabled with more dramatic changes
          if (showBorders) {
            if (tile.lit) {
              ctx.strokeStyle = '#FF0000' // Bright red border
              ctx.lineWidth = 3 // Thick border
            } else {
              ctx.strokeStyle = '#2E7D32'
              ctx.lineWidth = 1
            }
            ctx.strokeRect(
              transformedTile.x,
              transformedTile.y,
              transformedTile.size,
              transformedTile.size,
            )
          }
        }

        ctx.restore()

        // Continue animation if there are lit tiles
        if (litTiles.size > 0) {
          animationFrame = requestAnimationFrame(() => {
            drawTiles()
          })
        }
      }

      function updateTileStats() {
        const totalTiles = tiles.length
        const tileSize = parseInt(document.getElementById('tileSize').value)
        const tileArea = tileSize * tileSize
        const totalTileArea = totalTiles * tileArea

        // Calculate polygon area for coverage percentage
        let polygonArea = 0
        if (currentPolygon && currentPolygon.length >= 3) {
          for (let i = 0; i < currentPolygon.length; i++) {
            const j = (i + 1) % currentPolygon.length
            polygonArea += currentPolygon[i][0] * currentPolygon[j][1]
            polygonArea -= currentPolygon[j][0] * currentPolygon[i][1]
          }
          polygonArea = Math.abs(polygonArea) / 2
        }

        const coverage =
          polygonArea > 0 ? ((totalTileArea / polygonArea) * 100).toFixed(1) : 0

        document.getElementById('totalTiles').textContent = totalTiles
        document.getElementById('coveredArea').textContent = coverage + '%'
        document.getElementById('polygonVertices').textContent = currentPolygon
          ? currentPolygon.length
          : 0
        updateChainStats()
      }

      function toggleTiles() {
        showTiles = document.getElementById('showTiles').checked
        redraw()
      }

      function updateTiles() {
        const tileSize = parseInt(document.getElementById('tileSize').value)
        const opacity = parseFloat(document.getElementById('tileOpacity').value)

        document.getElementById('tileSizeValue').textContent = tileSize + 'px'
        document.getElementById('tileOpacityValue').textContent = opacity

        if (currentPolygon) {
          tiles = generateTiles(currentPolygon, tileSize)
          clearChainReaction() // Reset chain reaction when tiles change
          updateTileStats()
        }

        redraw()
      }

      // Handle canvas clicks
      function handleCanvasClick(event) {
        if (!enableInteraction || !showTiles || !tiles.length) {
          console.log('Click ignored: interaction disabled or no tiles')
          return
        }

        // Don't allow new chain reactions if one is already active or tiles are lit
        if (chainReactionActive || litTiles.size > 0) {
          console.log(
            'Click ignored: chain reaction active or tiles already lit',
          )
          return
        }

        const rect = canvas.getBoundingClientRect()
        const x = event.clientX - rect.left
        const y = event.clientY - rect.top

        // Convert canvas coordinates to tile coordinates
        const untransformedX = (x - offsetX) / scale
        const untransformedY = (y - offsetY) / scale

        console.log(
          `Click at canvas (${x}, ${y}), transformed to (${untransformedX.toFixed(1)}, ${untransformedY.toFixed(1)})`,
        )

        // Find clicked tile
        const clickedTile = tiles.find(
          (tile) =>
            untransformedX >= tile.x &&
            untransformedX < tile.x + tile.size &&
            untransformedY >= tile.y &&
            untransformedY < tile.y + tile.size,
        )

        if (clickedTile) {
          console.log(
            `Clicked tile: ${clickedTile.id} at (${clickedTile.x}, ${clickedTile.y}), already lit: ${clickedTile.lit}`,
          )
          if (!clickedTile.lit) {
            chainReaction(clickedTile)
          } else {
            console.log('Tile already lit, ignoring click')
          }
        } else {
          console.log('No tile found at click location')
        }
      }

      // Add click event listener
      canvas.addEventListener('click', handleCanvasClick)

      function drawBrain() {
        ctx.clearRect(0, 0, canvas.width, canvas.height)

        // Draw brain paths
        ctx.strokeStyle = '#333'
        ctx.lineWidth = 1
        ctx.fillStyle = 'rgba(200, 200, 200, 0.3)'

        for (const path of flattenedPaths) {
          if (path.length === 0) continue

          ctx.beginPath()
          const firstPoint = transformPoint(path[0])
          ctx.moveTo(firstPoint[0], firstPoint[1])

          for (let i = 1; i < path.length; i++) {
            const point = transformPoint(path[i])
            ctx.lineTo(point[0], point[1])
          }

          ctx.stroke()
          ctx.fill()
        }
      }

      function drawPolygon(polygon, color = '#ff0000', lineWidth = 3) {
        if (!polygon || polygon.length < 3) return

        ctx.strokeStyle = color
        ctx.fillStyle = 'rgba(255, 0, 0, 0.1)'
        ctx.lineWidth = lineWidth

        ctx.beginPath()
        const firstPoint = transformPoint(polygon[0])
        ctx.moveTo(firstPoint[0], firstPoint[1])

        for (let i = 1; i < polygon.length; i++) {
          const point = transformPoint(polygon[i])
          ctx.lineTo(point[0], point[1])
        }

        ctx.closePath()
        ctx.stroke()
        ctx.fill()
      }

      function redraw() {
        // Only cancel animation if we're not in the middle of a chain reaction
        if (animationFrame && litTiles.size === 0) {
          cancelAnimationFrame(animationFrame)
          animationFrame = null
        }

        drawBrain()
        if (currentPolygon) {
          drawPolygon(currentPolygon)
        }
        drawTiles()
      }

      function showPolygon(type) {
        // Update button states
        document
          .querySelectorAll('button')
          .forEach((btn) => btn.classList.remove('active'))
        document.getElementById(`btn-${type}`).classList.add('active')

        // Calculate polygon
        currentPolygon = calculateBrainPolygon(type)
        polygonType = type

        // Generate tiles for convex hull
        if (type === 'convex') {
          const tileSize = parseInt(document.getElementById('tileSize').value)
          tiles = generateTiles(currentPolygon, tileSize)
          clearChainReaction() // Reset chain reaction
          updateTileStats()
        } else {
          tiles = []
          clearChainReaction()
          updateTileStats()
        }

        // Update info
        const typeNames = {
          convex: 'Convex Hull',
          bounding: 'Bounding Box',
          alpha: 'Alpha Shape',
        }
        document.getElementById('polygon-info').textContent =
          `${typeNames[type]} - ${currentPolygon.length} vertices`

        // Update coordinates display
        document.getElementById('coordinates-display').textContent =
          JSON.stringify(currentPolygon, null, 2)

        // Redraw
        redraw()
      }

      function showBrainOnly() {
        // Update button states
        document
          .querySelectorAll('button')
          .forEach((btn) => btn.classList.remove('active'))
        document.getElementById('btn-brain').classList.add('active')

        currentPolygon = null
        polygonType = null
        tiles = []
        clearChainReaction()
        updateTileStats()

        document.getElementById('polygon-info').textContent =
          'Brain outline only'
        document.getElementById('coordinates-display').textContent =
          'No polygon selected'

        redraw()
      }

      // Initialize
      drawBrain()
      showPolygon('convex') // Start with convex hull
    </script>
  </body>
</html>
